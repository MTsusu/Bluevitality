/*
    vcl_recv：      实现安全策略，仅处理可识别的http方法且只缓存get/head，不缓存用户特有数据（据客户端请求作出缓存策略）
    vcl_fetch：     根据服务端的响应作出的策略缓存
    vcl_pipe:       用于将请求直接发往后端主机；
    vcl_hash:       自定义hash生成时的数据来源
    vcl_pass:       用于将请求直接传递至后端主机；
    vcl_hit:        从缓存中查找到缓存对象时要执行的操作；
    vcl_miss:       从缓存中款查找到缓存对象时要执行的操作；
    vcl_deliver:    将用户请求的内容响应给客户端时用到的方法；
    vcl_error:      在varnish端合成错误响应时的缓存策略；
*/

vcl 4.0;                                                    #版本兼容性，提供向后兼容

import directors;                                           #导入模块

probe check {                                               #健康检查参数
    .url = "/";                                             #检查路径
    .window = 8;                                            #检查次数
    .threshold = 4;                                         #最小健康次数
    .interval = 2s;                                         #检查频率2s/次
    .timeout = 1s;                                          #超时时长
}

backend default {                                           #定义后端主机
    
    .host = "172.16.252.205";                               #Host:port
    .port = "80";
    
    .connect_timeout = 0.5s;
    .first_byte_timeout = 20s;
    .between_bytes_timeout = 5s;
    .probe = check;
}

backend pic {
    
    .host = "172.16.253.145";
    .port = "80";
    
    .connect_timeout = 0.5s;
    .first_byte_timeout = 20s;
    .between_bytes_timeout = 5s;
    .probe = {
        .url = "/test.jpg";
        .timeout = 0.3 s; 
        .window = 8;
        .threshold = 3;
        .initial = 3;
    }
}

sub vcl_init {
    new grouphost = directors.round_robin();                #创建后端主机组，基于round_robin策略进行调度
    grouphost.add_backend(default);                         #还有grouphost.add_backend(default，1);？？？
    grouphost.add_backend(pic);                             #还有grouphost.add_backend(pic，1);？？？

    /*
    new img_cluster = directors.hash();
    img_cluster.add_backend(image1);
    img_cluster.add_backend(image2);
    */
}

acl purgers {
    "localhost";
    "127.0.0.1";
    "172.16.253.190";
}

sub vcl_recv {

    set req.backend_hint = grouphost.backend();             #还有set req.backend_hint = grouphost.backend(req.http.cookie);

    if (req.url ~ "test.html") {                            #测试页面不缓存
	    return(pass);
    }
    
    if (req.url ~ "^/admin.*") {
        return(pass);
    }
    
    if (req.restarts == 0){                                 #为第1次请求本主机的C端在向后端主机发生时添加HTTP头部"X-Forward-For"
        if (req.http.X-Forward-For) {                      
	        set req.http.X-Forward-For = req.http.X-Forward-For + "," +client.ip;
        } else {
	        set req.http.X-Forward-For = client.ip;
        }
    }
    
    if (req.request != "GET" &&                             #将不理解的HTTP方法直接交给后端服务器处理
        req.request != "HEAD" &&  
        req.request != "PUT" &&  
        req.request != "POST" &&  
        req.request != "TRACE" &&  
        req.request != "OPTIONS" &&  
        req.request != "DELETE") {  
            return (pipe);  
    }  
    
    if (req.method == "PURGE"){
        if (client.ip !~ purgers) {
            return (synth(444,"Not enough authority to " + client.ip));
        }
        return(purge);
    }

    if (req.method == "BAN") {
        if (client.ip !~ purgers) {
            return (synth(444,"Not enough authority to " + client.ip));
        }
        ban("req.http.host == " + req.http.host + " && req.url == " + req.url);
        return(synth(200,"Ban Added"));
    }
    
    /*  
    if (req.http.User-Agent ~ "(?i)curl") {
        return (synth(405,"No good"));
    }
    */
    retuen(lookup)
}

sub vcl_pass {  
    return (pass);  
}

sub vcl_hash {  
    hash_data(req.url);  
    if (req.http.host) {  
        hash_data(req.http.host);  
    } else {  
        hash_data(server.ip);  
    }  
    if(req.http.Accept-Encoding){                           ##持压缩的要增加,防止发送给不支持压缩的浏览器压缩的内容  
         hash_data(req.http.Accept-Encoding);  
    }
    return (hash);  
}

sub vcl_hit {   
    return (deliver);  
}

sub vcl_miss {  
    return (fetch);  
}

sub vcl_backend_response {
    if (bereq.url ~ "\.(jpg|jpeg|gif|png)$") {
	    set beresp.ttl = 6000s;
    }
    if (bereq.url ~ "\.(html|css|js)$") {
	    set beresp.ttl = 6000s;
    }
    if (beresp.http.Set-Cookie) {
	    return(deliver);
    }
}

sub vcl_deliver {
    if (obj.hits>0) {
        set resp.http.X-Cache = "HIT from "  + server.ip;
    } else {
        set resp.http.X-Cache = "MISS from " + server.ip;
    }
    
    unset resp.http.Vary;
    unset resp.http.X-Powered-By;
    unset resp.http.X-AspNet-Version;
}
