/*
    vcl_recv：      实现安全策略，仅处理可识别的http方法且只缓存get/head，不缓存用户特有数据（据客户端请求作出缓存策略）
    vcl_fetch：     根据服务端的响应作出的策略缓存
    vcl_pipe:       用于将请求直接发往后端主机；
    vcl_hash:       自定义hash生成时的数据来源
    vcl_pass:       用于将请求直接传递至后端主机；
    vcl_hit:        从缓存中查找到缓存对象时要执行的操作；
    vcl_miss:       从缓存中款查找到缓存对象时要执行的操作；
    vcl_deliver:    将用户请求的内容响应给客户端时用到的方法；
    vcl_error:      在varnish端合成错误响应时的缓存策略；
*/

vcl 4.0;                                                    #版本兼容性，提供向后兼容

import directors;                                           #导入模块

probe check {                                               #健康检查参数
    .url = "/";                                             #检查路径
    .window = 8;                                            #检查次数
    .threshold = 4;                                         #最小健康次数
    .interval = 2s;                                         #检查频率2s/次
    .timeout = 1s;                                          #超时时长
}

backend default {                                           #定义后端主机
    
    .host = "172.16.252.205";                               #Host:port
    .port = "80";
    
    .connect_timeout = 0.5s;
    .first_byte_timeout = 20s;
    .between_bytes_timeout = 5s;
    .probe = check;
}

backend pic {
    
    .host = "172.16.253.145";
    .port = "80";
    
    .connect_timeout = 0.5s;
    .first_byte_timeout = 20s;
    .between_bytes_timeout = 5s;
    .probe = {
        .url = "/test.jpg";
        .timeout = 0.3 s; 
        .window = 8;
        .threshold = 3;
        .initial = 3;
    }
}

sub vcl_init {
    new grouphost = directors.round_robin();                #调度方式？（暂时不确定，还有：new grouphos = directors.hash();）
    grouphost.add_backend(default);                         #还有grouphost.add_backend(default，1);？？？
    grouphost.add_backend(pic);                             #还有grouphost.add_backend(pic，1);？？？
}

sub vcl_recv {
    set req.backend_hint = grouphost.backend();             #还有set req.backend_hint = grouphost.backend(req.http.cookie);
｝


acl purgers {
    "localhost";
    "127.0.0.1";
    "172.16.253.190";
}

sub vcl_recv {
    set req.backend_hint = grouphost.backend();
    if (req.url ~ "(?i)^/admin") {
        return(pass);
    }
    if (req.method == "PURGE"){
        if (client.ip !~ purgers) {
            return (synth(444,"Not enough authority to " + client.ip));
        }
        return(purge);
    }

    if (req.method == "BAN") {
        if (client.ip !~ purgers) {
            return (synth(444,"Not enough authority to " + client.ip));
        }
        ban("req.http.host == " + req.http.host + " && req.url == " + req.url);
        return(synth(200,"Ban Added"));
    }
/*  if (req.http.User-Agent ~ "(?i)curl") {
        return (synth(405,"No good"));
    }
*/
    if (req.restarts ==0) {
        if (req.http.X-Forwarded-For) {
            set req.http.X-Forwarded-For = req.http.X-Forwarded-For + "," + client.ip;
        } else {
            set req.http.X-Forwarded-For = client.ip;
        }
    }
}

sub vcl_backend_response {
    if (beresp.http.cache-control !~ "s-maxage") {
        if (bereq.url ~ "(?i)\.(jpg|jpeg|gif|png|css|js)$") {
            unset beresp.http.Set_Cookie;
            set beresp.ttl = 7200s;
        }
    }
}

sub vcl_deliver {
    if (obj.hits>0) {
        set resp.http.X-Cache = "HIT from " + server.ip;
    } else {
        set resp.http.X-Cache = "MISS from " + server.ip;
    }
}
